---
title: "Terraform Provider"
description: "Manage Qovery infrastructure as code with Terraform"
---

## Overview

The Qovery Terraform Provider enables Infrastructure as Code (IaC) workflows for managing your entire Qovery infrastructure. Define applications, databases, environments, and clusters declaratively in Terraform configuration files, version control your infrastructure, and automate deployments through CI/CD pipelines.

## Why Use Terraform with Qovery?

<CardGroup cols={2}>
  <Card title="Infrastructure as Code" icon="file-code">
    Version control your infrastructure alongside application code
  </Card>

  <Card title="Reproducible Environments" icon="copy">
    Deploy identical setups across dev, staging, and production
  </Card>

  <Card title="Team Collaboration" icon="users">
    Review infrastructure changes through pull requests
  </Card>

  <Card title="Automation" icon="robot">
    Integrate with CI/CD pipelines for automated provisioning
  </Card>
</CardGroup>

## Installation

Add the Qovery provider to your Terraform configuration:

```hcl
terraform {
  required_providers {
    qovery = {
      source  = "qovery/qovery"
      version = "~> 0.45.0"
    }
  }
}

provider "qovery" {
  token = var.qovery_api_token
}
```

## Authentication

Generate an API token from the [Qovery Console](https://console.qovery.com):

1. Navigate to Organization Settings → API Tokens
2. Click "Generate Token"
3. Copy and securely store the token

Set as environment variable:

```bash
export QOVERY_API_TOKEN="your-api-token"
export TF_VAR_qovery_api_token="your-api-token"
```

<Warning>
Never commit API tokens to version control. Use environment variables or a secure secrets management solution like HashiCorp Vault or AWS Secrets Manager.
</Warning>

## Quick Start Example

```hcl
# Get organization
data "qovery_organization" "my_org" {
  name = "My Organization"
}

# Get project (can also be created with qovery_project resource)
data "qovery_project" "my_project" {
  organization_id = data.qovery_organization.my_org.id
  name            = "My Project"
}

# Get cluster (can also be created with qovery_cluster resource)
data "qovery_cluster" "prod_cluster" {
  organization_id = data.qovery_organization.my_org.id
  name            = "production"
}

# Create production environment
resource "qovery_environment" "production" {
  project_id = data.qovery_project.my_project.id
  cluster_id = data.qovery_cluster.prod_cluster.id
  name       = "production"
  mode       = "PRODUCTION"
}

# Deploy PostgreSQL database
resource "qovery_database" "main_db" {
  environment_id = qovery_environment.production.id
  name           = "main-database"
  type           = "POSTGRESQL"
  version        = "15"
  mode           = "MANAGED"
  storage        = 50
  accessibility  = "PRIVATE"
}

# Deploy application
resource "qovery_application" "api" {
  environment_id = qovery_environment.production.id
  name           = "api"

  git_repository = {
    url    = "https://github.com/my-org/my-api"
    branch = "main"
  }

  build_mode      = "DOCKER"
  dockerfile_path = "Dockerfile"

  ports = [{
    internal_port       = 3000
    external_port       = 443
    protocol            = "HTTP"
    publicly_accessible = true
  }]

  # Database connection automatically injected
  depends_on = [qovery_database.main_db]
}
```

## Managing Resources

### Supported Resources

The Qovery Terraform provider supports:

<AccordionGroup>
  <Accordion title="Core Resources" icon="cubes">
    - `qovery_project` - Projects to organize applications
    - `qovery_environment` - Dev, staging, production environments
    - `qovery_cluster` - Kubernetes cluster configuration
    - `qovery_labels_group` - Resource organization with labels
  </Accordion>

  <Accordion title="Applications & Services" icon="rocket">
    - `qovery_application` - Containerized applications
    - `qovery_container` - Custom container deployments
    - `qovery_job` - Cron jobs and lifecycle jobs
    - `qovery_helm` - Helm chart deployments
  </Accordion>

  <Accordion title="Databases" icon="database">
    - `qovery_database` - Managed databases
    - PostgreSQL, MySQL, MongoDB, Redis, SQL Server
    - Container or cloud-managed mode
    - Automatic connection string injection
  </Accordion>

  <Accordion title="Configuration" icon="sliders">
    - `qovery_environment_variable` - Environment-level variables
    - `qovery_environment_variable_alias` - Variable aliases
    - `qovery_environment_variable_override` - Override variables
    - `qovery_deployment_stage` - Control deployment order
  </Accordion>

  <Accordion title="Cloud Integration" icon="cloud">
    - `qovery_aws_credentials` - AWS cloud credentials
    - `qovery_scaleway_credentials` - Scaleway credentials
    - `qovery_gcp_credentials` - GCP credentials
    - `qovery_container_registry` - Container registries
  </Accordion>
</AccordionGroup>

## Workflow

### 1. Initialize Terraform

```bash
terraform init
```

### 2. Plan Changes

```bash
terraform plan
```

Review the proposed changes before applying.

### 3. Apply Configuration

```bash
terraform apply
```

Confirm the changes and Terraform will create/update resources.

### 4. Manage State

```hcl
# Remote state with S3 backend
terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "qovery/terraform.tfstate"
    region = "us-east-1"
  }
}
```

## Common Patterns

### Multi-Environment Setup

```hcl
locals {
  environments = {
    dev = {
      mode     = "DEVELOPMENT"
      replicas = 1
    }
    staging = {
      mode     = "STAGING"
      replicas = 2
    }
    production = {
      mode     = "PRODUCTION"
      replicas = 3
    }
  }
}

resource "qovery_environment" "envs" {
  for_each = local.environments

  project_id = data.qovery_project.my_project.id
  cluster_id = data.qovery_cluster.my_cluster.id
  name       = each.key
  mode       = each.value.mode
}

resource "qovery_application" "api" {
  for_each = local.environments

  environment_id = qovery_environment.envs[each.key].id
  name           = "api"

  git_repository = {
    url    = "https://github.com/my-org/api"
    branch = each.key == "production" ? "main" : each.key
  }

  auto_deploy = each.key != "production"
  min_running_instances = each.value.replicas
}
```

### Deployment Pipeline

```hcl
# Control deployment order with stages
resource "qovery_deployment_stage" "database" {
  environment_id = qovery_environment.prod.id
  name           = "Database"
  description    = "Deploy databases first"
}

resource "qovery_deployment_stage" "backend" {
  environment_id = qovery_environment.prod.id
  name           = "Backend"
  description    = "Deploy backend services"
  depends_on     = [qovery_deployment_stage.database]
}

resource "qovery_deployment_stage" "frontend" {
  environment_id = qovery_environment.prod.id
  name           = "Frontend"
  description    = "Deploy frontend last"
  depends_on     = [qovery_deployment_stage.backend]
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Use Variables" icon="code">
    ```hcl
    variable "qovery_api_token" {
      type      = string
      sensitive = true
    }

    variable "environment" {
      type    = string
      default = "production"
    }

    variable "replica_count" {
      type    = number
      default = 3
    }
    ```
  </Accordion>

  <Accordion title="Use Data Sources" icon="database">
    ```hcl
    # Look up resources by name instead of hardcoding IDs
    data "qovery_organization" "my_org" {
      name = "My Organization"
    }

    data "qovery_project" "my_project" {
      organization_id = data.qovery_organization.my_org.id
      name            = "My Project"
    }
    ```
  </Accordion>

  <Accordion title="Organize with Modules" icon="folder-tree">
    ```
    modules/
      ├── application/
      │   ├── main.tf
      │   ├── variables.tf
      │   └── outputs.tf
      ├── database/
      │   ├── main.tf
      │   ├── variables.tf
      │   └── outputs.tf
      └── environment/
          ├── main.tf
          ├── variables.tf
          └── outputs.tf
    ```
  </Accordion>

  <Accordion title="Remote State" icon="cloud">
    ```hcl
    terraform {
      backend "s3" {
        bucket         = "my-terraform-state"
        key            = "qovery/prod/terraform.tfstate"
        region         = "us-east-1"
        encrypt        = true
        dynamodb_table = "terraform-locks"
      }
    }
    ```
  </Accordion>

  <Accordion title="Separate Environments" icon="layer-group">
    ```
    environments/
      ├── dev/
      │   ├── main.tf
      │   ├── variables.tf
      │   └── terraform.tfvars
      ├── staging/
      │   ├── main.tf
      │   ├── variables.tf
      │   └── terraform.tfvars
      └── production/
          ├── main.tf
          ├── variables.tf
          └── terraform.tfvars
    ```
  </Accordion>
</AccordionGroup>

## Importing Existing Resources

Import existing Qovery resources into Terraform state:

```bash
# Import an application
terraform import qovery_application.my_app <application-id>

# Import an environment
terraform import qovery_environment.prod <environment-id>

# Import a database
terraform import qovery_database.postgres <database-id>
```

### Getting Resource IDs

Resource IDs can be obtained in two ways:

**1. From the Console URL**

IDs are available in the URL when viewing resources in the Qovery Console. For example:
- Application: `https://console.qovery.com/organization/xxx/project/yyy/environment/zzz/application/{application-id}`
- Environment: `https://console.qovery.com/organization/xxx/project/yyy/environment/{environment-id}`
- Database: `https://console.qovery.com/organization/xxx/project/yyy/environment/zzz/database/{database-id}`

**2. Using the Qovery CLI**

List resources and retrieve their IDs using CLI commands:

```bash
# List projects and their IDs
qovery project list

# List environments in current project
qovery environment list

# List applications in current environment
qovery application list

# List databases in current environment
qovery database list

# List clusters in organization
qovery cluster list
```

For more information, see the [CLI documentation](/cli/overview).

## CI/CD Integration

### GitHub Actions Example

```yaml
name: Terraform Deploy

on:
  push:
    branches: [main]

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        env:
          QOVERY_API_TOKEN: ${{ secrets.QOVERY_API_TOKEN }}
        run: terraform init

      - name: Terraform Plan
        env:
          QOVERY_API_TOKEN: ${{ secrets.QOVERY_API_TOKEN }}
        run: terraform plan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        env:
          QOVERY_API_TOKEN: ${{ secrets.QOVERY_API_TOKEN }}
        run: terraform apply -auto-approve
```

## Advantages Over Console

<CardGroup cols={2}>
  <Card title="Version Control" icon="code-branch">
    Track all infrastructure changes in Git with full history
  </Card>

  <Card title="Reproducibility" icon="clone">
    Recreate identical environments with a single command
  </Card>

  <Card title="Collaboration" icon="users">
    Review changes through pull requests before applying
  </Card>

  <Card title="Automation" icon="robot">
    Integrate with CI/CD for fully automated workflows
  </Card>

  <Card title="Documentation" icon="book">
    Infrastructure configuration serves as documentation
  </Card>

  <Card title="Drift Detection" icon="magnifying-glass">
    Detect manual changes made outside of Terraform
  </Card>

  <Card title="Scale Management" icon="arrows-up-to-line">
    Manage hundreds of resources efficiently
  </Card>

  <Card title="Consistency" icon="check-double">
    Enforce standards across all environments
  </Card>
</CardGroup>

## Limitations

<Warning>
**Note These Limitations**:
- Cannot manage organization-level settings (use Console)
- Some advanced features require Console or API
- State management requires proper backend configuration
- Import can be tedious for large existing infrastructures
</Warning>

## Next Steps

<CardGroup cols={2}>
  <Card title="Complete Documentation" icon="book" href="/terraform/overview">
    Full Terraform Provider documentation
  </Card>

  <Card title="Examples" icon="code" href="/terraform/examples">
    Real-world Terraform examples and patterns
  </Card>

  <Card title="Terraform Registry" icon="globe" href="https://registry.terraform.io/providers/Qovery/qovery/latest/docs">
    Official provider documentation
  </Card>

  <Card title="GitHub Repository" icon="github" href="https://github.com/Qovery/terraform-provider-qovery">
    Provider source code and issues
  </Card>
</CardGroup>

## Resources

- [Terraform Provider Registry](https://registry.terraform.io/providers/Qovery/qovery/latest/docs)
- [GitHub Repository](https://github.com/Qovery/terraform-provider-qovery)
- [Terraform Examples](/terraform/examples)
- [Qovery API Documentation](/api-reference/introduction)
