---
title: "Cloudflare Worker"
description: "Deploy Cloudflare Workers using Terraform with Qovery as the orchestrator"
---

## Overview

Deploy Cloudflare Workers—serverless functions that run at the edge—using Terraform, orchestrated by Qovery through Kubernetes. Build globally distributed applications with ultra-low latency by deploying your edge logic alongside your containerized services.

<Info>
**Edge Computing with Kubernetes Orchestration**: Qovery uses Kubernetes not just for containers, but as a universal orchestrator for any cloud resource, including edge functions like Cloudflare Workers.
</Info>

## Why Cloudflare Workers?

<CardGroup cols={2}>
  <Card title="Global Edge Network" icon="globe">
    Deploy to 300+ cities worldwide instantly
  </Card>

  <Card title="Ultra-Low Latency" icon="gauge-high">
    Millisecond response times from user's nearest location
  </Card>

  <Card title="Zero Cold Starts" icon="bolt">
    Workers start in less than 5ms
  </Card>

  <Card title="Cost Effective" icon="dollar-sign">
    100,000 requests/day free, then $0.50 per million
  </Card>

  <Card title="Built on V8" icon="code">
    Run JavaScript/TypeScript at the edge
  </Card>

  <Card title="Request/Response Manipulation" icon="wand-magic-sparkles">
    Modify traffic before it reaches your origin
  </Card>
</CardGroup>

## Use Cases

<AccordionGroup>
  <Accordion title="API Gateway" icon="gateway">
    - Authentication and authorization
    - Rate limiting and throttling
    - Request transformation
    - Response caching
    - API versioning
  </Accordion>

  <Accordion title="Edge Middleware" icon="filter">
    - A/B testing and feature flags
    - Bot detection and filtering
    - Geo-routing and localization
    - Header manipulation
    - Security hardening
  </Accordion>

  <Accordion title="Static Site Enhancement" icon="image">
    - Image optimization and resizing
    - Asset compression
    - Cache control
    - PWA service worker
    - HTML rewriting
  </Accordion>

  <Accordion title="Serverless APIs" icon="server">
    - Lightweight API endpoints
    - Data aggregation
    - Third-party API proxying
    - WebSocket handling
    - GraphQL endpoints
  </Accordion>
</AccordionGroup>

## Quick Start

### Deploy Simple Worker

<Steps>
  <Step title="Create Worker Script">
    ```javascript
    // worker.js
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })

    async function handleRequest(request) {
      const url = new URL(request.url)

      // Simple routing
      if (url.pathname === '/api/hello') {
        return new Response(JSON.stringify({
          message: 'Hello from the edge!',
          location: request.cf.colo,
          country: request.cf.country
        }), {
          headers: {
            'content-type': 'application/json',
            'cache-control': 'public, max-age=60'
          }
        })
      }

      // Proxy to origin
      return fetch(request)
    }
    ```
  </Step>

  <Step title="Create Terraform Configuration">
    ```hcl
    # cloudflare-worker.tf
    terraform {
      required_providers {
        cloudflare = {
          source  = "cloudflare/cloudflare"
          version = "~> 4.0"
        }
      }
    }

    provider "cloudflare" {
      api_token = var.cloudflare_api_token
    }

    # Upload worker script
    resource "cloudflare_worker_script" "api_gateway" {
      name    = "${var.environment}-api-gateway"
      content = file("${path.module}/worker.js")

      # Environment variables
      plain_text_binding {
        name = "ENVIRONMENT"
        text = var.environment
      }

      secret_text_binding {
        name = "API_KEY"
        text = var.api_key
      }

      # KV namespace binding
      kv_namespace_binding {
        name         = "CACHE"
        namespace_id = cloudflare_workers_kv_namespace.cache.id
      }

      # Service binding (call other workers)
      service_binding {
        name        = "AUTH_SERVICE"
        service     = cloudflare_worker_script.auth.name
        environment = var.environment
      }
    }

    # KV namespace for caching
    resource "cloudflare_workers_kv_namespace" "cache" {
      title = "${var.environment}-cache"
    }

    # Route configuration
    resource "cloudflare_worker_route" "api" {
      zone_id     = var.cloudflare_zone_id
      pattern     = "api.${var.domain}/*"
      script_name = cloudflare_worker_script.api_gateway.name
    }

    output "worker_url" {
      value = "https://api.${var.domain}"
    }
    ```

    ```hcl
    # variables.tf
    variable "cloudflare_api_token" {
      description = "Cloudflare API token"
      type        = string
      sensitive   = true
    }

    variable "cloudflare_zone_id" {
      description = "Cloudflare zone ID"
      type        = string
    }

    variable "environment" {
      description = "Environment name"
      type        = string
    }

    variable "domain" {
      description = "Domain name"
      type        = string
    }

    variable "api_key" {
      description = "API key for worker"
      type        = string
      sensitive   = true
    }
    ```
  </Step>

  <Step title="Deploy via Qovery Lifecycle Job">
    ```yaml
    # .qovery.yml
    version: "1.0"
    lifecycle_jobs:
      - name: deploy-cloudflare-worker
        image: hashicorp/terraform:latest
        on:
          - ENVIRONMENT_START
        commands:
          - /bin/sh
          - -c
          - |
            cd /workspace/terraform/cloudflare
            terraform init
            terraform apply -auto-approve \
              -var="environment=${QOVERY_ENVIRONMENT_NAME}" \
              -var="domain=${DOMAIN}" \
              -var="cloudflare_zone_id=${CF_ZONE_ID}" \
              -var="cloudflare_api_token=${CF_API_TOKEN}" \
              -var="api_key=${API_KEY}"

            terraform output -raw worker_url
        environment_variables:
          - name: CF_API_TOKEN
            secret: true
          - name: CF_ZONE_ID
            value: your-zone-id
          - name: DOMAIN
            value: example.com
          - name: API_KEY
            secret: true
    ```
  </Step>
</Steps>

## Advanced Examples

### API Gateway with Authentication

<Tabs>
  <Tab title="Worker Script">
    ```javascript
    // api-gateway-worker.js
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })

    async function handleRequest(request) {
      // CORS handling
      if (request.method === 'OPTIONS') {
        return handleCORS()
      }

      // Authentication
      const authHeader = request.headers.get('Authorization')
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return new Response('Unauthorized', { status: 401 })
      }

      const token = authHeader.substring(7)

      // Validate token (call auth service or check KV)
      const isValid = await validateToken(token)
      if (!isValid) {
        return new Response('Invalid token', { status: 403 })
      }

      // Rate limiting
      const clientIP = request.headers.get('CF-Connecting-IP')
      const rateLimitKey = `ratelimit:${clientIP}`
      const requestCount = await CACHE.get(rateLimitKey) || 0

      if (requestCount > 100) {
        return new Response('Rate limit exceeded', {
          status: 429,
          headers: {
            'Retry-After': '60'
          }
        })
      }

      // Increment rate limit counter
      await CACHE.put(rateLimitKey, parseInt(requestCount) + 1, {
        expirationTtl: 60
      })

      // Route to backend
      const url = new URL(request.url)
      const backendURL = `https://${BACKEND_HOST}${url.pathname}${url.search}`

      const response = await fetch(backendURL, {
        method: request.method,
        headers: request.headers,
        body: request.body
      })

      // Add security headers
      const newResponse = new Response(response.body, response)
      newResponse.headers.set('X-Frame-Options', 'DENY')
      newResponse.headers.set('X-Content-Type-Options', 'nosniff')
      newResponse.headers.set('Strict-Transport-Security', 'max-age=31536000')

      return newResponse
    }

    async function validateToken(token) {
      // Check KV cache first
      const cached = await CACHE.get(`token:${token}`)
      if (cached) return cached === 'valid'

      // Call auth service
      const response = await AUTH_SERVICE.fetch('https://auth/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token })
      })

      const isValid = response.ok
      // Cache result for 5 minutes
      await CACHE.put(`token:${token}`, isValid ? 'valid' : 'invalid', {
        expirationTtl: 300
      })

      return isValid
    }

    function handleCORS() {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400'
        }
      })
    }
    ```
  </Tab>

  <Tab title="Terraform">
    ```hcl
    resource "cloudflare_worker_script" "api_gateway" {
      name    = "${var.environment}-api-gateway"
      content = file("${path.module}/api-gateway-worker.js")

      plain_text_binding {
        name = "ENVIRONMENT"
        text = var.environment
      }

      plain_text_binding {
        name = "BACKEND_HOST"
        text = var.backend_host
      }

      kv_namespace_binding {
        name         = "CACHE"
        namespace_id = cloudflare_workers_kv_namespace.cache.id
      }

      service_binding {
        name        = "AUTH_SERVICE"
        service     = cloudflare_worker_script.auth.name
        environment = var.environment
      }
    }

    # Multiple routes
    resource "cloudflare_worker_route" "api_v1" {
      zone_id     = var.cloudflare_zone_id
      pattern     = "api.${var.domain}/v1/*"
      script_name = cloudflare_worker_script.api_gateway.name
    }

    resource "cloudflare_worker_route" "api_v2" {
      zone_id     = var.cloudflare_zone_id
      pattern     = "api.${var.domain}/v2/*"
      script_name = cloudflare_worker_script.api_gateway.name
    }
    ```
  </Tab>
</Tabs>

### Image Optimization

<Tabs>
  <Tab title="Worker Script">
    ```javascript
    // image-optimization-worker.js
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })

    async function handleRequest(request) {
      const url = new URL(request.url)

      // Parse image parameters from URL
      const params = new URLSearchParams(url.search)
      const width = parseInt(params.get('width')) || null
      const quality = parseInt(params.get('quality')) || 85
      const format = params.get('format') || 'auto'

      // Fetch original image
      const imageRequest = new Request(url.toString(), {
        cf: {
          image: {
            width: width,
            quality: quality,
            format: format
          }
        }
      })

      // Use Cloudflare Image Resizing
      const response = await fetch(imageRequest)

      // Cache for 1 day
      const newResponse = new Response(response.body, response)
      newResponse.headers.set('Cache-Control', 'public, max-age=86400')

      return newResponse
    }
    ```
  </Tab>

  <Tab title="Usage">
    ```html
    <!-- Original image -->
    <img src="https://images.example.com/photo.jpg" />

    <!-- Optimized versions -->
    <img src="https://images.example.com/photo.jpg?width=800&quality=85&format=webp" />
    <img src="https://images.example.com/photo.jpg?width=400&quality=80&format=avif" />

    <!-- Responsive images -->
    <picture>
      <source srcset="https://images.example.com/photo.jpg?width=1920&format=avif" media="(min-width: 1200px)" type="image/avif">
      <source srcset="https://images.example.com/photo.jpg?width=1200&format=webp" media="(min-width: 768px)" type="image/webp">
      <img src="https://images.example.com/photo.jpg?width=800" alt="Photo">
    </picture>
    ```
  </Tab>
</Tabs>

### A/B Testing and Feature Flags

<Tabs>
  <Tab title="Worker Script">
    ```javascript
    // ab-testing-worker.js
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })

    async function handleRequest(request) {
      const url = new URL(request.url)

      // Check for existing variant cookie
      let variant = getCookie(request, 'ab_variant')

      if (!variant) {
        // Assign variant based on feature flags from KV
        const featureFlags = await FEATURE_FLAGS.get('flags', { type: 'json' })

        // 50/50 split
        variant = Math.random() < 0.5 ? 'A' : 'B'

        // Override based on query param (for testing)
        if (url.searchParams.has('variant')) {
          variant = url.searchParams.get('variant')
        }
      }

      // Fetch appropriate version
      const backendURL = variant === 'B'
        ? `https://v2.${BACKEND_HOST}${url.pathname}`
        : `https://${BACKEND_HOST}${url.pathname}`

      const response = await fetch(backendURL, request)

      // Set variant cookie
      const newResponse = new Response(response.body, response)
      newResponse.headers.append(
        'Set-Cookie',
        `ab_variant=${variant}; Path=/; Max-Age=86400; HttpOnly; Secure; SameSite=Lax`
      )

      // Add variant header for analytics
      newResponse.headers.set('X-AB-Variant', variant)

      return newResponse
    }

    function getCookie(request, name) {
      const cookieString = request.headers.get('Cookie') || ''
      const cookies = cookieString.split(';')

      for (const cookie of cookies) {
        const [cookieName, cookieValue] = cookie.trim().split('=')
        if (cookieName === name) {
          return cookieValue
        }
      }

      return null
    }
    ```
  </Tab>

  <Tab title="Feature Flags in KV">
    ```json
    {
      "flags": {
        "new_ui": {
          "enabled": true,
          "rollout_percentage": 50,
          "allowlist": ["user123", "user456"]
        },
        "beta_feature": {
          "enabled": true,
          "rollout_percentage": 10
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Durable Objects

For stateful applications at the edge:

<Tabs>
  <Tab title="Durable Object">
    ```javascript
    // counter.js - Durable Object
    export class Counter {
      constructor(state, env) {
        this.state = state
      }

      async fetch(request) {
        const url = new URL(request.url)

        if (url.pathname === '/increment') {
          const count = (await this.state.storage.get('count')) || 0
          await this.state.storage.put('count', count + 1)
          return new Response(JSON.stringify({ count: count + 1 }))
        }

        if (url.pathname === '/get') {
          const count = (await this.state.storage.get('count')) || 0
          return new Response(JSON.stringify({ count }))
        }

        return new Response('Not found', { status: 404 })
      }
    }
    ```
  </Tab>

  <Tab title="Worker Using Durable Object">
    ```javascript
    // worker.js
    import { Counter } from './counter.js'

    export { Counter }

    export default {
      async fetch(request, env) {
        // Get or create a Durable Object instance
        const id = env.COUNTER.idFromName('global-counter')
        const stub = env.COUNTER.get(id)

        // Forward request to Durable Object
        return stub.fetch(request)
      }
    }
    ```
  </Tab>

  <Tab title="Terraform">
    ```hcl
    resource "cloudflare_worker_script" "stateful_app" {
      name    = "stateful-app"
      content = file("${path.module}/worker.js")

      # Durable Object binding
      durable_object_namespace_binding {
        name         = "COUNTER"
        namespace_id = cloudflare_workers_kv_namespace.counter_do.id
      }
    }
    ```
  </Tab>
</Tabs>

## Integration with Qovery Applications

### Worker as API Gateway for Containerized App

```yaml
# .qovery.yml
version: "1.0"

# Main application
applications:
  - name: backend-api
    git:
      repo: https://github.com/org/api
      branch: main
    instances:
      min: 2
      max: 10
    domains:
      - name: backend.internal.example.com
        internal: true  # Not publicly accessible

# Cloudflare Worker for edge logic
lifecycle_jobs:
  - name: deploy-edge-gateway
    image: hashicorp/terraform:latest
    on:
      - ENVIRONMENT_START
    commands:
      - /bin/sh
      - -c
      - |
        cd /workspace/terraform/cloudflare
        terraform init
        terraform apply -auto-approve \
          -var="backend_host=backend.internal.example.com" \
          -var="environment=${QOVERY_ENVIRONMENT_NAME}"
    environment_variables:
      - name: CF_API_TOKEN
        secret: true
```

## Best Practices

<AccordionGroup>
  <Accordion title="Performance" icon="gauge-high">
    - Keep workers under 1MB (uncompressed)
    - Minimize external API calls
    - Use KV for caching frequently accessed data
    - Leverage Durable Objects for stateful logic
    - Use service bindings instead of HTTP for worker-to-worker calls
    - Enable compression for responses
  </Accordion>

  <Accordion title="Security" icon="shield">
    - Always validate and sanitize input
    - Use secret bindings for sensitive data
    - Implement rate limiting
    - Add security headers
    - Validate JWTs at the edge
    - Use environment-specific API keys
  </Accordion>

  <Accordion title="Development Workflow" icon="code-branch">
    - Test locally with Wrangler CLI
    - Use preview environments for testing
    - Implement gradual rollout for changes
    - Monitor error rates and latency
    - Keep worker logic simple and focused
    - Version your worker scripts in Git
  </Accordion>

  <Accordion title="Cost Optimization" icon="dollar-sign">
    - Cache aggressively with KV
    - Use appropriate TTLs for cached data
    - Minimize Durable Object usage (more expensive)
    - Batch KV operations when possible
    - Monitor request count and optimize
  </Accordion>
</AccordionGroup>

## Monitoring

```hcl
# workers-analytics.tf
resource "cloudflare_logpush_job" "workers" {
  enabled          = true
  name            = "workers-logs"
  destination_conf = "s3://${aws_s3_bucket.logs.id}/workers?region=${var.aws_region}"
  dataset         = "workers_trace_events"
  frequency       = "high"

  logpull_options = join(",", [
    "fields=ClientIP,ClientRequestHost,ClientRequestMethod,ClientRequestURI,EdgeResponseStatus,EventTimestampMs",
    "timestamps=rfc3339"
  ])
}
```

**Metrics to Monitor**:
- Request count and rate
- Error rate (4xx, 5xx)
- CPU time per request
- KV operation latency
- Worker execution time

## Next Steps

<CardGroup cols={2}>
  <Card title="Google BigQuery" icon="chart-simple" href="/integrations/terraform/google-bigquery">
    Deploy BigQuery datasets with Terraform
  </Card>

  <Card title="AWS RDS" icon="database" href="/integrations/terraform/aws-rds">
    Provision RDS databases
  </Card>

  <Card title="Any Terraform Module" icon="infinity" href="/integrations/terraform/others">
    Deploy any Terraform resource with Qovery
  </Card>

  <Card title="Terraform Overview" icon="code" href="/integrations/terraform/overview">
    Learn more about Terraform integration
  </Card>
</CardGroup>
