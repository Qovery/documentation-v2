---
title: "New Relic Integration"
description: "Deploy New Relic APM and infrastructure monitoring via Helm chart"
---

## Overview

Deploy New Relic's comprehensive observability platform on your Qovery cluster using the official New Relic Helm chart (`nri-bundle`). Get full-stack monitoring including infrastructure, APM, Kubernetes observability, logs, and real-time alerting.

## Features

<CardGroup cols={2}>
  <Card title="Infrastructure Monitoring" icon="server">
    Monitor hosts, containers, and Kubernetes resources
  </Card>

  <Card title="APM" icon="chart-line">
    Application performance monitoring with distributed tracing
  </Card>

  <Card title="Kubernetes Monitoring" icon="dharmachakra">
    Deep Kubernetes insights with events and resource metrics
  </Card>

  <Card title="Log Management" icon="file-lines">
    Centralized log aggregation with context from metrics
  </Card>
</CardGroup>

## Prerequisites

<Check>New Relic account (sign up at [newrelic.com](https://newrelic.com))</Check>
<Check>New Relic License Key</Check>
<Check>Qovery cluster with Helm support</Check>

## Quick Start

### 1. Get New Relic License Key

<Steps>
  <Step title="Log into New Relic">
    Go to [one.newrelic.com](https://one.newrelic.com)
  </Step>

  <Step title="Navigate to API Keys">
    Account Settings → API keys
  </Step>

  <Step title="Create or Copy License Key">
    - Look for **INGEST - LICENSE** key
    - Click **Create a key** if none exists
    - Copy the license key (starts with NRAK-)
  </Step>
</Steps>

### 2. Deploy New Relic via Helm

<Steps>
  <Step title="Create Helm Service">
    In Qovery Console:
    1. Navigate to your environment
    2. Click **Create** → **Helm Chart**
    3. Name: `newrelic`
  </Step>

  <Step title="Configure Helm Repository">
    - **Repository**: `https://helm-charts.newrelic.com`
    - **Chart Name**: `nri-bundle`
    - **Chart Version**: `5.0.0` (or latest)
  </Step>

  <Step title="Add values.yaml">
    Create custom `values.yaml`:

    ```yaml
    global:
      # Your New Relic license key
      licenseKey: YOUR_NEWRELIC_LICENSE_KEY

      # Your cluster name (identifies cluster in New Relic)
      cluster: qovery-production

      # Set to true to send logs to New Relic
      lowDataMode: false

    # Kubernetes infrastructure monitoring
    newrelic-infrastructure:
      enabled: true
      privileged: true

      # Resource limits for infrastructure agent
      resources:
        limits:
          cpu: 200m
          memory: 300Mi
        requests:
          cpu: 100m
          memory: 150Mi

    # Kubernetes events monitoring
    kube-state-metrics:
      enabled: true

    # Prometheus metrics integration
    nri-prometheus:
      enabled: true

    # Kubernetes metadata injection
    nri-metadata-injection:
      enabled: true

    # Logging integration
    newrelic-logging:
      enabled: true

      # Forward all pod logs to New Relic
      fluentBit:
        enabled: true
        resources:
          limits:
            cpu: 500m
            memory: 128Mi
          requests:
            cpu: 250m
            memory: 64Mi

    # Kubernetes events
    nri-kube-events:
      enabled: true
    ```
  </Step>

  <Step title="Store License Key as Secret">
    **Option 1**: Use Qovery secrets (recommended)
    1. Go to Environment Variables
    2. Add secret: `NEWRELIC_LICENSE_KEY`
    3. Update values.yaml:
       ```yaml
       global:
         customSecretName: qovery-secrets
         customSecretLicenseKey: NEWRELIC_LICENSE_KEY
       ```

    **Option 2**: Inline (less secure)
    ```yaml
    global:
      licenseKey: nrak-XXXXXXXXXXXXXXXXXXXXXX
    ```
  </Step>

  <Step title="Deploy">
    Click **Deploy** and wait 2-3 minutes
  </Step>
</Steps>

### 3. Verify Installation

<Steps>
  <Step title="Check Pods">
    ```bash
    kubectl get pods -n qovery | grep newrelic
    # Should see:
    # - newrelic-nri-bundle-* (infrastructure agents on each node)
    # - newrelic-nri-kube-events-*
    # - newrelic-logging-* (on each node)
    ```
  </Step>

  <Step title="Check New Relic Dashboard">
    1. Log into New Relic One
    2. Go to Kubernetes cluster explorer
    3. Your cluster should appear within 2-3 minutes
  </Step>

  <Step title="Verify Data">
    - Infrastructure → Kubernetes: See cluster data
    - Logs → Logs: See pod logs
    - APM & Services: See APM data (after instrumentation)
  </Step>
</Steps>

## Instrumentation

### Enable APM for Your Applications

<Tabs>
  <Tab title="Node.js">
    **Install New Relic agent**:
    ```bash
    npm install newrelic
    ```

    **Create `newrelic.js` config**:
    ```javascript
    // newrelic.js
    'use strict'

    exports.config = {
      app_name: [process.env.NEW_RELIC_APP_NAME || 'my-app'],
      license_key: process.env.NEW_RELIC_LICENSE_KEY,

      // Automatically detect environment from Qovery
      labels: {
        environment: process.env.QOVERY_ENVIRONMENT_NAME || 'production',
        version: process.env.QOVERY_COMMIT_ID || 'unknown'
      },

      logging: {
        level: 'info'
      },

      // Distributed tracing
      distributed_tracing: {
        enabled: true
      },

      // Transaction tracer
      transaction_tracer: {
        enabled: true
      }
    }
    ```

    **Instrument application** (MUST be first require):
    ```javascript
    // index.js - FIRST LINE!
    require('newrelic');

    // Rest of your application
    const express = require('express');
    const app = express();

    app.get('/', (req, res) => {
      res.send('Hello World!');
    });

    app.listen(3000, () => {
      console.log('Server started on port 3000');
    });
    ```

    **Environment variables in Qovery**:
    ```bash
    NEW_RELIC_LICENSE_KEY=<your-key>
    NEW_RELIC_APP_NAME=my-app-production
    NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true
    NEW_RELIC_LOG_ENABLED=true
    ```
  </Tab>

  <Tab title="Python">
    **Install New Relic agent**:
    ```bash
    pip install newrelic
    ```

    **Option 1: Automatic instrumentation** (recommended):
    ```bash
    # Update Dockerfile CMD
    CMD ["newrelic-admin", "run-program", "python", "app.py"]
    ```

    **Option 2: Manual instrumentation**:
    ```python
    # app.py
    import newrelic.agent

    # Initialize before other imports
    newrelic.agent.initialize()

    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello():
        return 'Hello World!'

    if __name__ == '__main__':
        app.run()
    ```

    **Create `newrelic.ini`** (or use env vars):
    ```ini
    [newrelic]
    license_key = YOUR_LICENSE_KEY
    app_name = my-python-app

    distributed_tracing.enabled = true
    transaction_tracer.enabled = true
    error_collector.enabled = true
    ```

    **Environment variables**:
    ```bash
    NEW_RELIC_LICENSE_KEY=<your-key>
    NEW_RELIC_APP_NAME=my-python-app
    NEW_RELIC_CONFIG_FILE=newrelic.ini
    NEW_RELIC_ENVIRONMENT=production
    ```
  </Tab>

  <Tab title="Go">
    **Install New Relic agent**:
    ```bash
    go get github.com/newrelic/go-agent/v3/newrelic
    ```

    **Instrument application**:
    ```go
    package main

    import (
        "fmt"
        "log"
        "net/http"
        "os"

        "github.com/newrelic/go-agent/v3/newrelic"
    )

    func main() {
        // Initialize New Relic
        app, err := newrelic.NewApplication(
            newrelic.ConfigAppName(os.Getenv("NEW_RELIC_APP_NAME")),
            newrelic.ConfigLicense(os.Getenv("NEW_RELIC_LICENSE_KEY")),
            newrelic.ConfigDistributedTracerEnabled(true),
        )
        if err != nil {
            log.Fatal(err)
        }

        // Wrap HTTP handler
        http.HandleFunc(newrelic.WrapHandleFunc(app, "/", func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintf(w, "Hello World!")
        }))

        log.Fatal(http.ListenAndServe(":8080", nil))
    }
    ```

    **Environment variables**:
    ```bash
    NEW_RELIC_LICENSE_KEY=<your-key>
    NEW_RELIC_APP_NAME=my-go-app
    ```
  </Tab>

  <Tab title="Java">
    **Download Java agent**:
    ```dockerfile
    # In Dockerfile
    RUN wget https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip && \
        unzip newrelic-java.zip -d /opt/newrelic
    ```

    **Create `newrelic.yml`**:
    ```yaml
    common: &default_settings
      license_key: '<%= ENV["NEW_RELIC_LICENSE_KEY"] %>'
      app_name: <%= ENV["NEW_RELIC_APP_NAME"] %>

      distributed_tracing:
        enabled: true

      transaction_tracer:
        enabled: true

    production:
      <<: *default_settings
    ```

    **Update application startup**:
    ```bash
    java -javaagent:/opt/newrelic/newrelic.jar \
         -Dnewrelic.config.file=/opt/newrelic/newrelic.yml \
         -jar myapp.jar
    ```

    **Environment variables**:
    ```bash
    NEW_RELIC_LICENSE_KEY=<your-key>
    NEW_RELIC_APP_NAME=my-java-app
    ```
  </Tab>

  <Tab title=".NET">
    **Install New Relic agent**:
    ```bash
    # For .NET Core
    dotnet add package NewRelic.Agent
    ```

    **Update application**:
    ```csharp
    // Program.cs
    using NewRelic.Api.Agent;

    var builder = WebApplication.CreateBuilder(args);
    var app = builder.Build();

    app.MapGet("/", [Transaction] () => "Hello World!");

    app.Run();
    ```

    **Environment variables**:
    ```bash
    NEW_RELIC_LICENSE_KEY=<your-key>
    NEW_RELIC_APP_NAME=my-dotnet-app
    CORECLR_ENABLE_PROFILING=1
    CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A}
    CORECLR_NEWRELIC_HOME=/usr/local/newrelic-dotnet-agent
    CORECLR_PROFILER_PATH=/usr/local/newrelic-dotnet-agent/libNewRelicProfiler.so
    ```
  </Tab>
</Tabs>

## Advanced Configuration

### High Performance Mode

For large clusters, optimize resource usage:

```yaml
global:
  lowDataMode: true  # Reduces data sent to New Relic

newrelic-infrastructure:
  config:
    # Sample metrics less frequently
    metrics_sample_rate: 60  # Seconds

newrelic-logging:
  fluentBit:
    # Reduce log buffer size
    config:
      outputs: |
        [OUTPUT]
            Name newrelic
            Match *
            licenseKey ${LICENSE_KEY}
            endpoint ${ENDPOINT}
            lowDataMode true
```

### Custom Dashboards

Create custom dashboards in New Relic:

<Steps>
  <Step title="Navigate to Dashboards">
    New Relic One → Dashboards → Create dashboard
  </Step>

  <Step title="Add Charts">
    Use NRQL (New Relic Query Language):

    **CPU Usage**:
    ```sql
    SELECT average(cpuUsedCores)
    FROM K8sPodSample
    WHERE clusterName = 'qovery-production'
    FACET podName
    TIMESERIES
    ```

    **Memory Usage**:
    ```sql
    SELECT average(memoryUsedBytes / memoryLimitBytes * 100)
    FROM K8sPodSample
    WHERE clusterName = 'qovery-production'
    FACET podName
    ```

    **HTTP Request Rate**:
    ```sql
    SELECT rate(count(*), 1 minute)
    FROM Transaction
    WHERE appName = 'my-app'
    FACET request.uri
    ```
  </Step>
</Steps>

### Alert Policies

<Steps>
  <Step title="Create Alert Policy">
    Alerts & AI → Alert conditions → Create policy
  </Step>

  <Step title="Add Condition">
    **High CPU Usage**:
    ```sql
    SELECT average(cpuUsedCores)
    FROM K8sPodSample
    WHERE clusterName = 'qovery-production'
    AND podName LIKE 'my-app%'
    ```

    Threshold:
    - Critical: > 0.8 cores for 5 minutes
    - Warning: > 0.6 cores for 5 minutes
  </Step>

  <Step title="Configure Notifications">
    - Email
    - Slack
    - PagerDuty
    - Webhook
  </Step>
</Steps>

### Log Filtering

Filter logs to reduce ingestion costs:

```yaml
newrelic-logging:
  fluentBit:
    config:
      filters: |
        [FILTER]
            Name grep
            Match *
            # Only send ERROR and WARN logs
            Regex log level=(ERROR|WARN)

        [FILTER]
            Name modify
            Match *
            # Add custom attributes
            Add cluster qovery-production
            Add environment production
```

## Monitoring Features

### Infrastructure Monitoring

**What's Monitored**:
- Kubernetes nodes (CPU, memory, disk, network)
- Pods and containers
- Deployments, StatefulSets, DaemonSets
- Services and Ingresses
- Persistent Volumes
- Resource quotas and limits

**Access**: Infrastructure → Kubernetes → Cluster explorer

### APM Features

<AccordionGroup>
  <Accordion title="Distributed Tracing" icon="diagram-project">
    - End-to-end request tracing across microservices
    - Service dependency maps
    - Trace waterfall view showing each span
    - Slow transaction identification
    - Error correlation with traces
  </Accordion>

  <Accordion title="Transaction Analysis" icon="chart-line">
    - Transaction response times (p50, p95, p99)
    - Throughput (requests per minute)
    - Error rates
    - Apdex score
    - Database query performance
    - External service call times
  </Accordion>

  <Accordion title="Service Maps" icon="sitemap">
    - Automatic service discovery
    - Dependency visualization
    - Health status per service
    - Traffic flow between services
    - Alert status overlay
  </Accordion>

  <Accordion title="Database Monitoring" icon="database">
    - Query performance
    - Slow queries
    - Query execution plans
    - Lock wait times
    - Connection pool metrics
  </Accordion>
</AccordionGroup>

### Log Management

- **Log-in-context**: See logs related to specific transactions
- **Log patterns**: Automatically detect common log patterns
- **Full-text search**: Search across all logs
- **Faceting**: Group by service, pod, severity
- **Custom parsing**: Extract fields from logs

## Best Practices

<CardGroup cols={2}>
  <Card title="Tag Everything" icon="tags">
    Use consistent tagging:
    ```yaml
    global:
      labels:
        environment: production
        team: platform
        cost-center: engineering
    ```
    Makes filtering and grouping easier
  </Card>

  <Card title="Set Up Key Alerts" icon="bell">
    Alert on actionable metrics:
    - High error rates (> 5%)
    - Slow transactions (p95 > 2s)
    - Pod crashes
    - Memory leaks
    Don't alert on everything!
  </Card>

  <Card title="Create Team Dashboards" icon="chart-mixed">
    Build dashboards for each team:
    - Service health overview
    - Key business metrics
    - SLI/SLO tracking
    - Cost metrics
  </Card>

  <Card title="Use Service Levels" icon="gauge-high">
    Define SLIs and SLOs:
    - Availability: 99.9% uptime
    - Latency: p95 < 500ms
    - Error rate: < 1%
    Track SLO burn rate
  </Card>
</CardGroup>

## Cost Optimization

<CardGroup cols={2}>
  <Card title="Enable Low Data Mode" icon="arrow-down">
    ```yaml
    global:
      lowDataMode: true
    ```
    Reduces data ingestion by ~50%
  </Card>

  <Card title="Sample High-Volume Logs" icon="filter">
    Don't send all logs:
    ```yaml
    # Only send ERROR logs
    fluentBit:
      config:
        filters: |
          [FILTER]
              Name grep
              Regex log level=ERROR
    ```
  </Card>

  <Card title="Right-Size Agents" icon="arrows-minimize">
    Adjust resource requests:
    ```yaml
    newrelic-infrastructure:
      resources:
        requests:
          cpu: 50m
          memory: 100Mi
    ```
  </Card>

  <Card title="Monitor Usage" icon="chart-line">
    Track your New Relic usage:
    - Account settings → Usage
    - Monitor GB ingested
    - Check host count
    - Review retention settings
  </Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="No Data in New Relic">
    **Problem**: Cluster deployed but no data appearing

    **Solutions**:
    - Verify license key is correct
    - Check pod logs: `kubectl logs -n qovery <newrelic-pod>`
    - Ensure network access to New Relic endpoints
    - Wait 5-10 minutes for initial data
    - Verify correct New Relic region (US vs EU)
  </Accordion>

  <Accordion title="APM Data Missing">
    **Problem**: Infrastructure data present, but no APM traces

    **Solutions**:
    - Verify application has New Relic agent installed
    - Check agent is initialized FIRST in application
    - Ensure `NEW_RELIC_LICENSE_KEY` env var is set
    - Check application logs for New Relic agent errors
    - Verify distributed tracing is enabled
  </Accordion>

  <Accordion title="High Memory Usage">
    **Problem**: New Relic agents using too much memory

    **Solutions**:
    - Enable `lowDataMode`
    - Reduce sample rates
    - Increase resource limits
    - Filter logs before sending
    - Disable unused features (e.g., Prometheus scraping)
  </Accordion>

  <Accordion title="Logs Not Appearing">
    **Problem**: Infrastructure and APM work, but no logs

    **Solutions**:
    - Verify `newrelic-logging` is enabled
    - Check FluentBit pods are running
    - Ensure pods write to stdout/stderr
    - Review FluentBit filters (may be filtering too aggressively)
    - Check log ingestion quota in New Relic account
  </Accordion>
</AccordionGroup>

## New Relic vs Datadog

| Feature | New Relic | Datadog |
|---------|-----------|---------|
| **Pricing Model** | Per-user + data | Per-host + data |
| **Free Tier** | 100 GB/month free | 5 hosts free |
| **APM** | Excellent | Excellent |
| **Infrastructure** | Good | Excellent |
| **Logs** | Good | Excellent |
| **Alerting** | Good | Excellent |
| **UI/UX** | Modern, intuitive | Powerful, complex |
| **Query Language** | NRQL (SQL-like) | Proprietary |
| **Best For** | Teams wanting simple pricing | Large enterprises, complex setups |

## Next Steps

<CardGroup cols={2}>
  <Card title="New Relic Docs" icon="book" href="https://docs.newrelic.com/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure/">
    Official New Relic Kubernetes docs
  </Card>

  <Card title="Deploy Datadog" icon="datadog" href="/integrations/observability/datadog">
    Alternative observability platform
  </Card>

  <Card title="Qovery Observe" icon="chart-mixed" href="/integrations/observability/qovery-observe">
    Built-in observability option
  </Card>

  <Card title="Other Solutions" icon="chart-network" href="/integrations/observability/other-solutions">
    Explore Prometheus, Grafana, and more
  </Card>
</CardGroup>
