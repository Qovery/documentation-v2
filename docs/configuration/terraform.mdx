---
title: "Terraform"
description: "Deploy and manage Terraform modules natively on Qovery"
---

## Overview

<img src="/images/logos/terraform-icon.svg" alt="Terraform" class="terraform-icon" /> Qovery provides native support for deploying Terraform modules directly from your Git repositories. This allows you to manage infrastructure as code (IaC) alongside your applications, using the same deployment workflow.

<Info>
Terraform on Qovery enables you to provision cloud resources, manage external services, and configure infrastructure using the same GitOps workflow as your applications.
</Info>

**Key Benefits**:
- **Native Integration**: Deploy Terraform modules directly from Git repositories
- **Automatic State Management**: Qovery manages Terraform state automatically
- **Environment Variables**: Inject secrets and configuration as Terraform variables
- **GitOps Workflow**: Changes to Terraform code trigger automatic deployments
- **Multi-Cloud**: Use any Terraform provider (AWS, GCP, Azure, Scaleway, etc.)

## Use Cases

<CardGroup cols={2}>
  <Card title="External Resources" icon="cloud">
    Provision cloud resources not natively supported by Qovery (S3 buckets, CloudFront, etc.)
  </Card>

  <Card title="Third-Party Services" icon="plug">
    Configure external SaaS providers (Cloudflare, SendGrid, Auth0, etc.)
  </Card>

  <Card title="Custom Infrastructure" icon="wrench">
    Deploy custom infrastructure configurations specific to your needs
  </Card>

  <Card title="Data Services" icon="database">
    Provision managed databases, caches, or data warehouses with custom settings
  </Card>
</CardGroup>

## How It Works

Qovery runs your Terraform modules as part of your environment deployment:

1. **Code Push**: Push Terraform code to your Git repository
2. **Automatic Detection**: Qovery detects changes in your Terraform modules
3. **Plan Execution**: Terraform plan runs to preview changes
4. **Apply**: Terraform apply provisions or updates resources
5. **State Management**: Terraform state is stored securely by Qovery

<Info>
Qovery runs `terraform plan` during the build phase and `terraform apply` during deployment, following Terraform best practices.
</Info>

## Creating a Terraform Service

<Steps>
  <Step title="Navigate to Environment">
    Go to your environment where you want to add a Terraform service
  </Step>

  <Step title="Create Terraform Service">
    Click **New Service** → **Terraform**
  </Step>

  <Step title="Configure Repository">
    **Git Repository Settings**:
    - **Repository**: Select your Git repository
    - **Branch**: Choose the branch to deploy from
    - **Root Path**: Path to your Terraform module (default: `/`)
  </Step>

  <Step title="Configure Terraform Settings">
    **Terraform Configuration**:
    - **Name**: Service identifier (e.g., `s3-buckets`, `cloudflare-dns`)
    - **Description**: Optional description
    - **Terraform Version**: Select version (e.g., 1.5.0, 1.6.0, 1.7.0)
  </Step>

  <Step title="Configure Variables">
    Add Terraform variables as environment variables:
    - **TF_VAR_***: Terraform input variables
    - **AWS_ACCESS_KEY_ID**, **AWS_SECRET_ACCESS_KEY**: Cloud credentials
    - Custom provider credentials
  </Step>

  <Step title="Deploy">
    Click **Create** to provision the Terraform service
  </Step>
</Steps>

## Terraform Module Structure

Your repository should follow standard Terraform structure:

```
terraform/
├── main.tf           # Main Terraform configuration
├── variables.tf      # Input variables
├── outputs.tf        # Output values
├── providers.tf      # Provider configuration
└── terraform.tfvars  # Variable values (optional)
```

### Example: S3 Bucket Module

<CodeGroup>
```hcl main.tf
# Create S3 bucket for application storage
resource "aws_s3_bucket" "app_storage" {
  bucket = var.bucket_name

  tags = {
    Environment = var.environment
    ManagedBy   = "Qovery"
  }
}

resource "aws_s3_bucket_versioning" "app_storage" {
  bucket = aws_s3_bucket.app_storage.id

  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_public_access_block" "app_storage" {
  bucket = aws_s3_bucket.app_storage.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}
```

```hcl variables.tf
variable "bucket_name" {
  description = "Name of the S3 bucket"
  type        = string
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}
```

```hcl outputs.tf
output "bucket_name" {
  description = "Name of the created S3 bucket"
  value       = aws_s3_bucket.app_storage.id
}

output "bucket_arn" {
  description = "ARN of the created S3 bucket"
  value       = aws_s3_bucket.app_storage.arn
}

output "bucket_region" {
  description = "Region of the created S3 bucket"
  value       = aws_s3_bucket.app_storage.region
}
```

```hcl providers.tf
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}
```
</CodeGroup>

## Environment Variables

### Terraform Input Variables

Qovery automatically passes environment variables prefixed with `TF_VAR_` to Terraform:

```bash
# In Qovery Console
TF_VAR_bucket_name=my-app-storage
TF_VAR_environment=production
TF_VAR_aws_region=us-east-1
```

These become available in Terraform as:
```hcl
var.bucket_name
var.environment
var.aws_region
```

### Provider Credentials

Configure cloud provider credentials as secrets:

<Tabs>
  <Tab title="AWS">
    ```bash
    AWS_ACCESS_KEY_ID=AKIA...
    AWS_SECRET_ACCESS_KEY=secret...
    AWS_DEFAULT_REGION=us-east-1
    ```
  </Tab>

  <Tab title="GCP">
    ```bash
    GOOGLE_CREDENTIALS={"type":"service_account",...}
    GOOGLE_PROJECT=my-project-id
    GOOGLE_REGION=us-central1
    ```
  </Tab>

  <Tab title="Azure">
    ```bash
    ARM_CLIENT_ID=xxx
    ARM_CLIENT_SECRET=xxx
    ARM_SUBSCRIPTION_ID=xxx
    ARM_TENANT_ID=xxx
    ```
  </Tab>

  <Tab title="Cloudflare">
    ```bash
    CLOUDFLARE_API_TOKEN=xxx
    CLOUDFLARE_ZONE_ID=xxx
    ```
  </Tab>
</Tabs>

<Tip>
Use Qovery **Secrets** for sensitive credentials to ensure they're encrypted and never exposed in logs.
</Tip>

## State Management

Qovery automatically manages Terraform state for you:

**State Storage**:
- State files are stored securely by Qovery
- Encrypted at rest
- Automatic state locking
- State versioning and history

**State Operations**:
- `terraform plan`: Preview changes without modifying state
- `terraform apply`: Apply changes and update state
- State is preserved across deployments
- Rollback support via environment cloning

<Warning>
**Never** manually edit Terraform state files. Qovery handles state management automatically.
</Warning>

## Deployment Workflow

### GitOps Workflow

Terraform deployments follow the same GitOps workflow as applications:

1. **Commit Changes**: Push Terraform code changes to Git
2. **Automatic Trigger**: Qovery detects changes and starts deployment
3. **Plan Phase**: `terraform plan` runs to preview changes
4. **Review**: Check plan output in deployment logs
5. **Apply Phase**: `terraform apply` provisions resources
6. **Outputs**: Terraform outputs are available as environment variables

### Manual Deployment

You can also trigger deployments manually:

<Steps>
  <Step title="Navigate to Terraform Service">
    Go to your Terraform service in Qovery Console
  </Step>

  <Step title="Deploy">
    Click **Deploy** to trigger a new deployment
  </Step>

  <Step title="Monitor Logs">
    View real-time logs showing `terraform plan` and `terraform apply` output
  </Step>
</Steps>

## Terraform Outputs

Terraform outputs are automatically exported as environment variables:

```hcl outputs.tf
output "bucket_name" {
  value = aws_s3_bucket.app_storage.id
}

output "cdn_url" {
  value = aws_cloudfront_distribution.cdn.domain_name
}
```

These become available to other services as:
```bash
QOVERY_TERRAFORM_<SERVICE_NAME>_OUTPUT_BUCKET_NAME=my-app-storage
QOVERY_TERRAFORM_<SERVICE_NAME>_OUTPUT_CDN_URL=d111111abcdef8.cloudfront.net
```

<Info>
Use Terraform outputs to share resource information with your applications, such as bucket names, URLs, or connection strings.
</Info>

## Advanced Configuration

### Multiple Terraform Modules

Deploy multiple Terraform services in the same environment:

```
Environment: Production
├── App: web-app
├── Database: postgres-db
├── Terraform: s3-storage      # S3 buckets
├── Terraform: cloudflare-dns  # DNS configuration
└── Terraform: monitoring      # CloudWatch/metrics
```

Each Terraform service manages its own resources independently.

### Terraform Workspaces

Use Terraform workspaces for environment separation:

```hcl
variable "environment" {
  description = "Environment name"
  type        = string
}

resource "aws_s3_bucket" "app_storage" {
  bucket = "${var.environment}-app-storage"

  tags = {
    Environment = var.environment
    Workspace   = terraform.workspace
  }
}
```

Set `TF_WORKSPACE` environment variable in Qovery:
```bash
TF_WORKSPACE=production
```

### Backend Configuration

Qovery manages the Terraform backend automatically. However, you can specify backend configuration for advanced use cases:

```hcl backend.tf
terraform {
  backend "s3" {
    # Qovery will inject backend config automatically
    # No configuration needed here
  }
}
```

<Warning>
Custom backend configuration is typically not needed. Qovery's automatic backend management is recommended for most use cases.
</Warning>

## Common Patterns

### AWS S3 + CloudFront

```hcl
# S3 bucket for static assets
resource "aws_s3_bucket" "static_assets" {
  bucket = var.bucket_name
}

# CloudFront distribution
resource "aws_cloudfront_distribution" "cdn" {
  origin {
    domain_name = aws_s3_bucket.static_assets.bucket_regional_domain_name
    origin_id   = "S3-${aws_s3_bucket.static_assets.id}"
  }

  enabled = true

  default_cache_behavior {
    allowed_methods        = ["GET", "HEAD"]
    cached_methods         = ["GET", "HEAD"]
    target_origin_id       = "S3-${aws_s3_bucket.static_assets.id}"
    viewer_protocol_policy = "redirect-to-https"

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }
  }

  viewer_certificate {
    cloudfront_default_certificate = true
  }

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }
}

output "cdn_url" {
  value = aws_cloudfront_distribution.cdn.domain_name
}
```

### Cloudflare DNS Records

```hcl
# DNS record for application
resource "cloudflare_record" "app" {
  zone_id = var.cloudflare_zone_id
  name    = var.subdomain
  value   = var.app_endpoint
  type    = "CNAME"
  proxied = true
}

# SSL/TLS settings
resource "cloudflare_zone_settings_override" "app" {
  zone_id = var.cloudflare_zone_id

  settings {
    ssl = "strict"
    always_use_https = "on"
    min_tls_version = "1.2"
  }
}

output "dns_record_name" {
  value = cloudflare_record.app.hostname
}
```

### RDS Database with Custom Configuration

```hcl
resource "aws_db_instance" "app_db" {
  identifier = var.db_identifier

  engine               = "postgres"
  engine_version       = "15.4"
  instance_class       = var.db_instance_class
  allocated_storage    = var.db_storage
  storage_encrypted    = true

  db_name  = var.db_name
  username = var.db_username
  password = var.db_password

  vpc_security_group_ids = [aws_security_group.db.id]
  db_subnet_group_name   = aws_db_subnet_group.db.name

  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "mon:04:00-mon:05:00"

  enabled_cloudwatch_logs_exports = ["postgresql", "upgrade"]

  tags = {
    ManagedBy = "Qovery"
  }
}

output "db_endpoint" {
  value = aws_db_instance.app_db.endpoint
}

output "db_connection_string" {
  value = "postgresql://${var.db_username}:${var.db_password}@${aws_db_instance.app_db.endpoint}/${var.db_name}"
  sensitive = true
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Use Version Control">
    Always commit Terraform code to Git and use Qovery's GitOps workflow for deployments. Never apply changes manually outside Qovery.
  </Accordion>

  <Accordion title="Organize with Modules">
    Structure your Terraform code using modules for reusability:
    ```
    terraform/
    ├── modules/
    │   ├── s3-bucket/
    │   ├── cloudfront/
    │   └── rds-database/
    └── environments/
        ├── production/
        └── staging/
    ```
  </Accordion>

  <Accordion title="Manage Secrets Securely">
    - Use Qovery **Secrets** for sensitive variables
    - Never commit credentials to Git
    - Use Terraform's `sensitive = true` for outputs containing secrets
    - Rotate credentials regularly
  </Accordion>

  <Accordion title="Pin Provider Versions">
    Always specify provider versions to ensure consistent deployments:
    ```hcl
    terraform {
      required_providers {
        aws = {
          source  = "hashicorp/aws"
          version = "~> 5.0"  # Pin to major version
        }
      }
    }
    ```
  </Accordion>

  <Accordion title="Use Terraform Outputs">
    Export important resource information via outputs so other services can use them:
    ```hcl
    output "bucket_name" {
      description = "S3 bucket for app storage"
      value       = aws_s3_bucket.app.id
    }
    ```
  </Accordion>

  <Accordion title="Test in Staging First">
    - Test Terraform changes in staging environment
    - Use environment-specific variables
    - Validate outputs before promoting to production
  </Accordion>

  <Accordion title="Review Plans Before Applying">
    Always review `terraform plan` output in deployment logs before applying changes to understand what will be modified.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Terraform Init Fails">
    **Symptoms**: Deployment fails during initialization

    **Common Causes**:
    - Invalid provider version
    - Missing provider credentials
    - Terraform version incompatibility

    **Solutions**:
    1. Check Terraform version compatibility
    2. Verify provider credentials are set correctly
    3. Review provider version constraints
    4. Check deployment logs for specific error
  </Accordion>

  <Accordion title="Plan Shows Unexpected Changes">
    **Symptoms**: `terraform plan` shows changes you didn't make

    **Possible Causes**:
    - Manual changes in cloud console
    - Terraform state drift
    - Variable changes

    **Solutions**:
    1. Review deployment logs to see what changed
    2. Check if resources were modified outside Terraform
    3. Verify environment variables are correct
    4. Consider using `terraform refresh` to sync state
  </Accordion>

  <Accordion title="Apply Fails with Resource Already Exists">
    **Symptoms**: Error saying resource already exists

    **Solutions**:
    1. Import existing resource into Terraform state:
       ```bash
       terraform import aws_s3_bucket.example bucket-name
       ```
    2. Or delete the existing resource and let Terraform recreate it
    3. Check for resource naming conflicts
  </Accordion>

  <Accordion title="Outputs Not Available">
    **Symptoms**: Terraform outputs not appearing as environment variables

    **Solutions**:
    1. Verify outputs are defined in `outputs.tf`
    2. Check that Terraform apply completed successfully
    3. Redeploy dependent services to refresh variables
    4. Check output naming follows conventions
  </Accordion>

  <Accordion title="Permission Denied Errors">
    **Symptoms**: AWS/GCP/Azure permission errors

    **Solutions**:
    1. Verify cloud credentials have sufficient permissions
    2. Check IAM policies for required actions
    3. Ensure credentials are not expired
    4. Review provider-specific error messages
  </Accordion>
</AccordionGroup>

## Limitations

<Warning>
Be aware of these limitations when using Terraform on Qovery:
</Warning>

- **No Interactive Approval**: `terraform apply` runs automatically without interactive approval
- **State Access**: Direct access to Terraform state files is not provided (managed by Qovery)
- **Terraform Commands**: Only `plan` and `apply` commands are executed automatically
- **Execution Time**: Long-running Terraform operations may timeout (default: 30 minutes)

## Next Steps

<CardGroup cols={2}>
  <Card title="Terraform Provider" icon="code" href="/terraform-provider/overview">
    Use Qovery Terraform Provider to manage Qovery resources
  </Card>

  <Card title="Terraform Examples" icon="book" href="/terraform-provider/basic-application">
    Browse example Terraform configurations
  </Card>

  <Card title="Lifecycle Jobs" icon="clock" href="/configuration/lifecycle-job">
    Run scripts during deployment lifecycle
  </Card>

  <Card title="Environment Variables" icon="key" href="/configuration/environment-variables">
    Manage environment variables and secrets
  </Card>
</CardGroup>
